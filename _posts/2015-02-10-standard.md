---
author: someone
title: Структуры CSS-кода
featimg: cssmain.jpg
tags: [text]
category: [Статья]
---
Разработчик Бен Фрейн (Ben Frain) однажды заметил: «Писать CSS-код легко. Масшабировать и поддерживать его — нет».

К счастью, на просторах интернета можно найти множество решений этой проблемы. В данной статье рассмотрены основные киты структуры CSS-кода, а также интересные рыбы/млекопитающие поменьше.

Статья служит лишь памяткой или кратким справочником — для подробного ознакомления с методологиями настоятельно рекомендуется изучать оригинальную документацию.

Итак, начнем.<br>
<h2>БЭМ</h2>
<img src="https://habrastorage.org/files/dc4/809/03a/dc480903af774eab9370c85e50c8ac72.png" class="img-responsive image-center thumbnail " alt="image"/><br/>
Автор: <a href="https://ru.bem.info/authors/">Яндекс</a><br>
<a href="https://ru.bem.info/">Документация</a>

Пожалуй, самая популярная сейчас методология в мире. Название означает «Блок, элемент, модификатор». 

Эти категории играют следующие роли в коде:

> блоки могут использоваться в нескольких местах сайта;
> элементы являются частью блока и не имеют функционального смысла вне блока;
> модификаторы представляют собой свойства блока или элемента, которые меняют его внешний вид или поведение.

Из этих категорий строятся классы для непосредственного использования в CSS. При этом не следует использовать селекторы тэгов (это потенциально может помешать использовать блок/элемент в каком-то нестандартном месте на сайте, т.е. привязывает сущность к контексту); рекомендуется также избегать каскадных селекторов, т.к. получившийся класс сам по себе достаточно точно (специфично) выбирает соответствующий элемент.

Такой подход позволяет избавиться от непредсказуемых последствий каскада и изолирует отдельные модули друг от друга.

Пример кода в стиле БЭМ:

    # .block_element {...}
      .block_element-modifier {...}
     
Для удобства используются разные разделители между блоком и элементом и между блоком/элементом и модификатором; при этом можно использовать любые разделители, однако они должны быть одинаковыми в рамках одного проекта.

А теперь о бочках меда и ложках дегтя:<br>
Хорошо: изолированность модулей друг от друга и отсутствие непредсказуемых каскадов селекторов.<br>
Плохо: не всегда длинные названия классов удобны для использования (для крупных проектов есть смысл использовать инструменты, автоматизирующие работу с БЭМ-разметкой).

Кстати, для написания кода в таком стиле раньше часто рекомендовали препроцессор Stylus, так как он позволяет писать код так:

    # .block {
        &-element {...}
       }

Сейчас так можно писать, используя как SASS, так и LESS.

И еще одно замечание — в оригинальной методологии БЭМ используются названия модификаторов, содержащие саму модифицируемую величину, например, button--sizeLarge. Сейчас в небольших проектах многие разработчики не указывают ее для лаконичности: button--large.

<a href="https://ru.bem.info/forum/-147/">Здесь</a> можно почитать про историю создания БЭМ.

<h2>OOCSS</h2>
<img src="https://habrastorage.org/files/466/3e3/813/4663e38131c24db99aa009b4a55d3235.png" class="img-responsive image-center thumbnail" alt="image"/><br/>
Автор: <a href="http://www.stubbornella.org/content/nicole-sullivan/">Николь Салливан (Nicole Sullivan)</a><br>
<a href="http://www.slideshare.net/stubbornella/object-oriented-css">Презентация</a>
OOCSS означает объектно-ориентированный CSS (Object-Oriented CSS). В этот подход заложены две основные идеи:<br/>
<br/>
<ul>
<li>Разделение структуры и оформления</li>
<li>Разделение контейнера и контента (содержимого)</li>
</ul><br/>
Итак, «разделяй и властвуй». С помощью такой структуры разработчик получает общие классы, которые можно использовать в разных местах.<br/>
<br/>
А теперь — две новости (как водится, хорошая и плохая):<br/>
<br/>
<ul>
<li>Хорошая: уменьшение количества кода за счет повторного его использования (принцип DRY).</li>
<li>Плохая: достаточно сложная поддержка: при изменении стиля конкретного элемента скорее всего придется менять не только CSS (т.к. большинство классов общие), но и добавлять классы в разметку.</li>
</ul><br/>
Кроме того, сам подход OOCSS предлагает не конкретные правила, а абстрактные рекомендации, поэтому метод достаточно сложен для применения на практике. <br/>
<br/>
Зато, как это иногда случается, некоторые идеи OOCSS вдохновили авторов на создание своих, более конкретных, способов структурирования кода — своеобразных форков OOCSS.<br/>
<a name="smacss"></a><br/>
<h2>SMACSS</h2><br/>
<img src="https://habrastorage.org/files/4dc/24a/8dc/4dc24a8dc3fb4e758adf89af4f73f66c.png" class="img-responsive image-center thumbnail" alt="image"/><br/>
<br/>
Автор: <a href="https://smacss.com/book/about">Джонатан Снук (Jonathan Snook)</a><br/>
<a href="https://smacss.com/">Документация</a><br/>
<br/>
SMACSS расшифровывается как «масштабируемая и модульная архитектура для CSS» (Scalable and Modular Architecture for CSS). <br/>
<br/>
Основная цель подхода — уменьшение количества кода и на упрощение поддержки кода. <br/>
<br/>
Итак, Джонатан предложил разделить стили на 5 частей (в порядке включения их в документ):<br/>
<br/>
<ol>
<li><b>Base rules</b> — базовые стили. Это стили основных элементов сайта — body, input, button, ul, ol и т.п. В этой секции используются в основном селекторы тэгов и атрибутов, классы — в исключительных случаях (например, если у вас стилизованные JavaScript’ом селекты);</li>
<li><b>Layout rules</b> — стили макета. Здесь находятся стили глобальных элементов размеры шапки, футера, сайдбара и т.п. Джонатан предлагает использовать здесь id в селекторах, так как эти элементы не будут встречаться более 1 раза на странице. <i>Однако автор статьи считает это плохой практикой (каждый раз, когда в стилях появляется id селектор, где-то в мире грустит котенок). Используйте классы и будет вам счастье.</i></li>
<li><b>Modules rules</b> — стили модулей, то есть блоков, которые могут использоваться несколько раз на одной странице. Для классов модулей не рекомендуется использовать id и селекторы тэгов (для многократного использования и независимости от контекста соответственно).</li>
<li><b>State rules</b> — стили состояния. В этом разделе прописываются различные состояния модулей и скелета сайта. Это единственный раздел, в котором допустимо использование ключевого слова «!important».</li>
<li><b>Theme rules</b> — оформление. Здесь описываются стили оформлений, которые со временем, возможно, нужно будет заменить (так удобно делать, например, новогоднее оформление; для html-тем, выставленных на продажу такие стили позволяют переключать цветовую гамму и т.п.).</li>
</ol><br/>
Также рекомендуется вводить неймспейсы для классов, принадлежащих к определенной группе, а также использовать отдельный неймспейс для классов, используемых в JavaScript.<br/>
<br/>
Этот подход действительно позволяет упростить написание и поддержку кода и в последнее время привлекает достаточно большое количество разработчиков.<br/>

<h2>Atomic CSS</h2><br/>
<img src="https://habrastorage.org/files/b93/1f4/75b/b931f475b0984db391f1ae5cad45bced.png" class="img-responsive image-center thumbnail" alt="image"/><br/>
<br/>
Автор: <a href="https://twitter.com/thierrykoblentz">Тьерри Коблентц (Thierry Koblentz) — Yahoo</a><br/>
<a href="http://www.smashingmagazine.com/2013/10/21/challenging-css-best-practices-atomic-approach/">Оригинальная статья</a><br/>
<br/>
Atomic CSS, редко также ACSS — атомарный CSS. В некотором роде этот подход представляет собой OOCSS, возведенный в абсолют. <br/>
<br/>
При использовании такого подхода для каждого повторно используемого свойства должен быть сформирован отдельный класс. Пример: стиль «margin-top: 1px» предполагает создание класса «mt-1», стиль «width: 200px» создание класса «w-200». <br/>
<br/>
Такой стиль позволяет минимизировать объем CSS-кода за счет повторного использования деклараций, а также сравнительно легко вводить изменения в модули, к примеру, при изменении технического задания.<br/>
<br/>
Однако у этого подхода есть существенные недостатки! Вот они:<br/>
<br/>
<ul>
<li>наименования классов представляют собой описательные названия свойств, не описывая семантическую сущность элемента, что иногда может усложнить разработку;</li>
<li>настройки отображения элементов переносятся непосредственно в HTML (это не то, для чего были придуманы таблицы стилей, не так ли?).</li>
</ul><br/>
В связи с этими недостатками, подход был встречен существенным объемом критики. Тем не менее, подход может оказаться эффективным для очень больших проектов — кажется, Yahoo! вполне довольны использованием ACSS (<a href="https://www.haikudeck.com/atomic-css-science-and-technology-presentation-dJ0xlFjhBQ#">ссылка на интересную презентацию того же Тьерри Коблентца</a>).<br/>
Кроме того, атомарный CSS используется в различных фреймворках для задания корректирующих стилей элементов и в некоторых слоях других методологий. <br/>
<br/>

<h2>MCSS</h2><br/>
<img src="https://habrastorage.org/files/041/ae2/293/041ae229321745fe88c7205e514e5b90.png" class="img-responsive image-center thumbnail"/><br/>
<br/>
Автор: <a href="http://rhr.me/">Роберт Харитонов — Одноклассники</a><br/>
<a href="http://operatino.github.io/MCSS/">Документация</a><br/>
<br/>
<blockquote>«Огры как лук. У огров есть слои. И у лука есть слои. У тех и у других есть слои»</blockquote> Шрек<br/>
<br/>
MCSS — многослойный CSS (Multilayer CSS). Этот стиль написания кода, зародившийся в компании «Одноклассники», предлагает разделить стили на несколько частей, называемых <b>слоями</b>.<br/>
<br/>
<ul>
<li><b>Нулевой слой</b> или <b>фундамент</b> — здесь содержится код, отвечающий за сброс стилей браузера (reset.css/normalize.css);</li>
<li><b>Базовый слой</b> — включает в себя стили многократно используемых на сайте элементов: кнопок, полей ввода для текста, подсказок и т.п.;</li>
<li><b>Проектный слой</b> — включает в себя отдельные модули, а также т.н. «контекст» — модификации элементов в зависимости от браузера клиента, устройства, на котором просматривается сайт/приложение, роли пользователя и т.п.;</li>
<li><b>Косметический слой</b> — в этом разделе находится код, написанный в стиле OOCSS, осуществляющий мелкие изменения в внешнем виде элементов. Здесь рекомендуется оставлять только стили, влияющие на внешний вид и не способные поломать верстку сайта — цвета, некоторые некритичные отступы.</li>
</ul><br/>
Очень важна иерархия взаимодействия слоев:<br/>
<br/>
<ul>
<li>Слой фундамента задает нейтральные стили и не влияет на другие слои. </li>
<li>Элементы базового слоя могут влиять только на классы своего же слоя. <i>Пример: иконки на сайте могут иметь размеры 25x25, но иконки в кнопках — 16x16.</i></li>
<li>Элементы проектного слоя могут влиять на базовый и проектный слой. <i>Примеры: иконки в форме логина имеют особый размер 20x20; модуль «Покупка» может включать в себя форму логина, стили которой несколько модифицированы.</i></li>
<li>Косметический слой оформлен в виде описательных OOCSS-классов («атомарные» классы) и не влияет на другой CSS-код, избирательно применяясь в разметке.</li>
</ul><br/>
Рекомендую также просмотреть <a href="http://rhr.me/pres/mcss/">отличную презентацию</a>, посвященную MCSS — там вы сможете узнать больше о MCSS и не только.<br/>
<br/>

<h2>AMCSS</h2><br/>
<img src="https://habrastorage.org/files/9ee/1d0/988/9ee1d098849a4b04ad300e32a6d17099.png" class="img-responsive image-center thumbnail"/><br/>
<br/>
Автор: <a href="https://twitter.com/glenmaddern">Глен Маддерн (Glen Maddern)</a><br/>
<a href="https://amcss.github.io/">Документация</a><br/>
<br/>
Название подхода означает «Модули атрибутов для CSS» (Attribute Modules for CSS). Это достаточно необычный подход, упоминания которого, тем не менее, все чаще встречаются в блогах гуру разработки.<br/>
<br/>
Если обобщить, этот способ является несколько более человеко-читаемым представлением БЭМ-структуры. Давайте рассмотрим пример:<br/>
<br/>
<pre><code class="html">&lt;div class=&quot;button button--large button--blue&quot;&gt;Кнопка&lt;/div&gt;
</code></pre><br/>
Такая цепочка классов не очень приятна для глаз, поэтому давайте сгруппируем эти значения по атрибутам.<br/>
<br/>
Вот что получится:<br/>
<br/>
<pre><code class="html">&lt;div button=&quot;large blue&quot;&gt;Кнопка&lt;/div&gt;
</code></pre><br/>
Во избежание коллизий имен неплохо бы добавить атрибутам неймспейсы, не так ли? Тогда код нашей кнопки примет следующий вид:<br/>
<br/>
<pre><code class="html">&lt;div am-button=&quot;large blue&quot;&gt;Кнопка&lt;/div&gt;
</code></pre><br/>
Если вы используете валидатор для проверки кода на корректность, не забывайте также добавить приставку «data-» перед названием атрибута.<br/>
<br/>
Для записи CSS-кода используется малоизвестный селектор «~=» (IE7+), который работает как атрибут класса: выбирает элементы, значения атрибутов которых содержат указанные слова, разделенные пробелами. Так, селектор вида a[class~=«link»][class~=«button»] аналогичен селектору a.class.button (даже по специфичности, так как специфичности селекторов по классу и по атрибуту равны друг другу!).<br/>
<br/>
Соответственно, CSS-код<br/>
<br/>
<pre><code class="css">.button {...}
.button--large {...}
.button--blue{...}
</code></pre><br/>
Преобразуется в <br/>
<br/>
<pre><code class="css">[am-button] {...}
[am-button~=&quot;large&quot;] {...}
[am-button~=&quot;blue&quot;] {...}
</code></pre><br/>
Ну как? Если вы считаете такой код слишком оригинальным, для вас существует менее радикальная форма использования AMCSS:<br/>
<br/>
<pre><code class="html">&lt;div am-button am-button-large am-button-blue&gt;&lt;/div&gt;
</code></pre><br/>
<a name="fun"></a><br/>
<h2>FUN</h2><br/>
<img src="https://habrastorage.org/files/2b3/462/864/2b34628642c34a839b89a438495f74d0.png" class="img-responsive image-center thumbnail"/><br/>
<br/>
Автор: <a href="https://plus.google.com/107588612045728705538/posts">Бен Фрейн (Ben Frain)</a><br/>
<a href="http://benfrain.com/enduring-css-writing-style-sheets-rapidly-changing-long-lived-projects/">Оригинальная статья</a><br/>
<br/>
FUN означает «плоская иерархия селекторов, служебные стили, компоненты с неймспейсами» (Flat hierarchy of selectors, Utility styles, Name-spaced components). Ну или веселье =)<br/>
<br/>
За каждой буквой названия стоит определенный принцип:<br/>
<br/>
<ul>
<li>F, плоская иерархия селекторов: в стилях рекомендуется использовать классы для выбора элементов, не вкладывать селекторы (избегать каскада без необходимости), а также не использовать id (если вы читали раздел БЭМ, вспомните про котят);</li>
<li>U, служебные классы: поощряется создание служебных атомарных стилей для решения типовых задач верстки, например, w100 для «width: 100%» или fr для «float: right»;</li>
<li>N, компоненты с неймспейсами: Бен рекомендует добавлять неймспейсы для задания стилей элементов конкретных модулей; такой подход позволит избежать совпадений в названиях классов.</li>
</ul><br/>
Некоторые разработчики отмечают, что код, написанный с использованием этих принципов достаточно удобно писать и поддерживать; в некотором роде автор взял лучшее от БЭМ и SMACSS и изложил эти техники в простой и лаконичной форме.<br/>
<br/>
Такой подход накладывает достаточно мало требований по структуре кода и проекта, он лишь устанавливает предпочтительную форму записи селекторов и способ их использования в разметке. Но в небольших проектах этих правил может быть вполне достаточно для создания качественного кода.<br/>

<h2>Заключение</h2><br/>
Вот и все!<br/>
<br/>
Как видите, среди этих подходов нет идеального — все они обладают своими плюсами и минусами.<br/>
Поэтому мне остается лишь напомнить вам, что ни один из этих подходов не является абсолютной догмой — вы можете взять подход из начать творить что-то свое, или создать новый подход с нуля. И, может быть, именно этот метод позволит вебу подняться на следующую ступень.<br/>
<br/>
Спасибо за внимание!<br>
<h4>Источник</h4><a href="https://ru.bem.info/">habrahabr</a>
