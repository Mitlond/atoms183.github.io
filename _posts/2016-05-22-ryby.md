---
author: atoms
type: ryby
featimg: maxresdefault.jpg
title: «Обработка Markdown в Ruby»
tags: [Статьи, Обучение]
category: [Статьи]
layout: post-classic-sidebar-left
---
Markdown это фантастический язык разметки, компилируемый в HTML. Хотя изначально он написан на Perl, Markdown портирован на многие языки с различными функциями. В этой статье мы рассмотрим 4 имплементации Markdown на Ruby: kramdown, maruku, rdiscount и redcarpet.

Обработка Markdown в Ruby
Очевидно, что сначала надо установить нужные модули — gem install kramdown maruku rdiscount redcarpet. Это может занять время, так как RDiscount и Redcarpet используют расширения C для ускорения парсинга.

Также это означает то, что если ваш интерпретатор Ruby не поддерживает расширения C, вы не сможете использовать RDiscount или Redcarpet (это актуально при использовании JRuby).

Для нашего теста мы будем использовать тестовый файл в Markdown со страницы Джона Грубера, сохранив его под именем markup.md.

В каждой имплементации для обработки Markdown достаточно одной строчки кода.
<pre><code class="css">markdown = File.read('markup.md')

# kramdown
require 'kramdown'
Kramdown::Document.new(markdown).to_html

# maruku
require 'maruku'
Maruku.new(markdown).to_html

# rdiscount
require 'rdiscount'
RDiscount.new(markdown).to_html

# redcarpet
require 'redcarpet'
Redcarpet::Markdown.new(Redcarpet::Render::HTML.new).render(markdown)</code></pre>
Отлично! Мы видим, что в каждом фреймворке (за исключением Redcarpet) есть простой API для обработки Markdown.

<h4>Функционал</h4>
Оригинальная имплементация Markdown была хороша, но люди всегда хотят большего. Например, в оригинальном Markdown есть поддержка изображений и блоков с кодом, но многие пользователи были заинтересованы в другом синтаксисе и в лучшей расширяемости этих функций. Таким образом, функционал различных имплементаций Markdown может значительно расширяться.<br>

Рассмотрим несколько наиболее популярных расширений и их поддержку в Ruby-имплементациях Markdown.

<h4>Блоки кода</h4>
Синтаксис блоков кода изначально предусматривал выделение кода отступами:
<pre><code class="css"> if foo == bar
       "Markdown is awesome."
     end</code></pre>
Улучшенный синтаксис называется <b>fenced code blocks</b>— огороженные блоки кода. Он выглядит так:
<pre><code class="css">```ruby
		if foo == bar
  			"Markdown is awesome."
		end
	</code></pre>
	
Язык (в данном случае Ruby) указывается сразу после окончания первой ограды. Это опционально, но позволяет парсеру Markdown реализовывать подсветку кода с учетом синтаксиса языка.

<h5>Зачеркивание</h5>
Зачеркивание это еще одна добавленная фича в Markdown, оно реализуется путем оборачивания нужного слова или фразы тильдами~.
<pre><code class="css">~~Something outdated~~</code></pre>
<h5>Таблицы</h5>
Таблицы это добавленная в Markdown возможность. Разметка таблиц в Markdown напоминает упрощенный вариант таблиц в простом тексте.
<pre><code class="css">   
| Header 1 | Header 2 | Header 3 |
|----------|----------|----------|
| Foo      | Bar      | Baz      |
 </code></pre>
На выходе мы получаем простую HTML-таблицу.
<pre><code class="css">   

Header 1	Header 2	Header 3
  Foo	     Bar	      Baz

 </code></pre>
Хотя такой синтаксис удобен для создания простых таблиц, он кажется неудобным при создании более сложных таблиц, с различным размером контента в ячейках. Но это на самом деле не имеет значения, так как достаточно только подчеркнуть заголовок и разделять ячейки таблиц вертикальными чертами.
<pre><code class="css">   
| Header 1      | Header 2|Header 3 |
|-------|----|----------|
|Foo|Bar|Baz|

 </code></pre>
<pre><code class="css">   

Header 1	Header 2	Header 3
Foo	     Bar	      Baz

 </code></pre>
<h5>Идентификаторы заголовков</h5>
Эта возможность позволяет добавлять анкеры в HTML (http://something.com/document.html#id-ref) в документы markdown. Это делается автоматически в заголовках и подзаголовках. Однако в каждой из имплементаций этот механизм отличен от других, поэтому лучше будет начать с документации.

<h5>Улучшенная типографика (расширение “SmartyPants”)</h5>
Одним из самых востребованных расширений является еще один проект Daring Fireball под названием SmartyPants. Оно позволяет заменять традиционную ASCII пунктуацию на правильную, типографскую. Например:
<pre><code class="css">"Ruby", the programming language.
Превращается в: “Ruby”, the programming language.</code></pre>
Кроме изменения внешнего вида кавычек, двойной дефис заменяется на м-тире, а тройной на н-тире.

<h5>Сравнение</h5>
Теперь посмотрим на поддержку этих расширений в имлементациях Markdown в Ruby:

 <table> <thead> <tr> <th>Процессор</th> <th>Fenced Code</th> <th>Зачеркивание</th> <th>Таблицы</th> <th>ID для заголовков</th> <th>Улучшенная типографика</th> </tr> </thead> <tbody> <tr> <td>Kramdown</td> <td>Да</td> <td>Нет</td> <td>Да</td> <td>Да</td> <td>Да</td> </tr> <tr> <td>Maruku</td> <td>Да</td> <td>Нет</td> <td>Да</td> <td>Да</td> <td>Да</td> </tr> <tr> <td>Redcarpet</td> <td>Да</td> <td>Да</td> <td>Да</td> <td>Да</td> <td>Да</td> </tr> <tr> <td>RDiscount</td> <td>Да</td> <td>Да</td> <td>Да</td> <td>Нет</td> <td>Да</td> </tr> </tbody> </table> 
<h5>Производительность</h5>
Я протестировал все процессоры Markdown, использовав этот файл. В Ruby это делается достаточно легко с помощью модуля Benchmark. Вот мои настройки:
<pre><code class="language-ruby">require 'benchmark'

markdown = File.read('TestDoc.md')

Benchmark.bm(15) do |x|
  x.report('Kramdown') {
    require 'kramdown'
    Kramdown::Document.new(markdown.dup).to_html
  }

  x.report('Maruku') {
    require 'maruku'
    Maruku.new(markdown.dup).to_html
  }

  x.report('RDiscount') {
    require 'rdiscount'
    RDiscount.new(markdown.dup).to_html
  }

  x.report('RedCarpet') {
    require 'redcarpet'
    Redcarpet::Markdown.new(Redcarpet::Render::HTML.new).render(markdown.dup)
  }
end
</code></pre>






